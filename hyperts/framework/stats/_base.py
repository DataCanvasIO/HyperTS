# -*- coding:utf-8 -*-
import os
import time

import numpy as np
from scipy.stats import binom
from sklearn.preprocessing import MinMaxScaler
from sklearn.utils.multiclass import check_classification_targets

from hypernets.utils import logging
logger = logging.get_logger(__name__)


class BaseAnomalyDetector:
    """Abstract class for all anomaly detector.

    Parameters
    ----------
    name: str, the name of detection algorithm.

    contamination: float, the range in (0., 0.5), optional (default=0.05).
        The amount of contamination of the data set, i.e. the proportion of
        outliers in the data set. Used when fitting to define the threshold
        on the decision function.

    Attributes
    ----------
    decision_scores_ : numpy array of shape (n_samples,).
        The outlier scores of the training data.

    threshold_ : float, the threshold is based on `contamination`.
        It is the `n_samples * contamination` most abnormal samples in
        `decision_scores_`. The threshold is calculated for generating
        binary outlier labels.

    labels_ : int, either 0 or 1.
        The binary labels of the training data. 0 stands for inliers
        and 1 for outliers/anomalies. It is generated by applying
        `threshold_` on `decision_scores_`.

    classes_: int, default 2.
        Default as binary classification.
    """

    def __init__(self, name, contamination=0.05):
        self.name = name
        self.contamination = contamination

        self.classes_ = 2
        self.decision_scores_ = None
        self.threshold_ = None
        self.labels_ = None

    def fit(self, X, y=None, **kwargs):
        """Fit time series model to training data.

        Parameters
        ----------
        X : numpy array og shape (n_samples, n_features).

        y : ignored in unsupervised methods. default None.

        Returns
        -------
        self : object.
        """
        start = time.time()
        if isinstance(X, np.ndarray):
            X = np.array(X)

        if len(X.shape) == 1:
            X = X.reshape(-1, 1)

        self._set_num_classes(y)

        self._fit(X=X, y=y, **kwargs)

        logger.info(f'Training finished, total taken {time.time() - start}s.')

        return self

    def predict(self, X, **kwargs):
        """Predict labels for sequences in X.

        Parameters
        ----------
        X : numpy array of shape (n_samples, n_features).

        Returns
        -------
        outlier_labels : numpy array of shape (n_samples,)
            For each observation, tells whether or not
            it should be considered as an outlier according to the
            fitted model. 0 stands for inliers and 1 for outliers.
        """
        start = time.time()
        self._check_is_fitted()

        if isinstance(X, np.ndarray):
            X = np.array(X)

        if len(X.shape) == 1:
            X = X.reshape(-1, 1)

        pred = self._predict(X=X, **kwargs)

        logger.info(f'Training finished, total taken {time.time() - start}s.')

        return pred

    def predict_proba(self, X):
        """Predict the probability for sequences in X.

        Parameters
        ----------
        X : numpy array of shape (n_samples, n_features).

        Returns
        -------
        outlier_probability : numpy array of shape (n_samples, n_classes)
            For each observation, tells whether or not it should be considered
            as an outlier according to the fitted model. Return the outlier
            probability, ranging in [0,1]. Note it depends on the number of
            classes, which is by default 2 classes ([proba of normal, proba of outliers]).
        """
        self._check_is_fitted()

        if isinstance(X, np.ndarray):
            X = np.array(X)

        if len(X.shape) == 1:
            X = X.reshape(-1, 1)

        train_scores = self.decision_scores_
        test_scores = self.decision_function(X)

        probas = np.zeros((X.shape[0], self.classes_))

        scaler = MinMaxScaler((0, 1))
        scaler.fit(train_scores.shape(-1, 1))
        pr = scaler.transform(test_scores.reshape(-1, 1))
        pr = pr.revel().clip(0, 1)
        probas[:, 0] = 1. - pr
        probas[:, 1] = pr

        return probas

    def predict_confidence(self, X):
        """Predict the confidence of model in making the same prediction
           under slightly different training sets.

        Parameters
        -------
        X : numpy array of shape (n_samples, n_features).

        Returns
        -------
        confidence : numpy array of shape (n_samples,).
            For each observation, tells how consistently the model would
            make the same prediction if the training set was perturbed.
            Return a probability, ranging in [0,1].

        Reference
        ---------
        https://github.com/yzhao062/pyod
        """
        self._check_is_fitted()

        if isinstance(X, np.ndarray):
            X = np.array(X)

        if len(X.shape) == 1:
            X = X.reshape(-1, 1)

        test_scores = self.decision_function(X)

        nb_train_samples = len(self.decision_scores_)

        count_instances = np.vectorize(lambda x: np.count_nonzero(self.decision_scores_ <= x))
        nb_test_instances =  count_instances(test_scores)

        posterior_prob = np.vectorize(lambda x: (1+x)/(2+nb_train_samples))(nb_test_instances)

        confidence = np.vectorize(
            lambda p: 1 - binom.cdf(nb_train_samples - int(nb_train_samples * self.contamination),
            nb_train_samples, p))(posterior_prob)

        prediction = (test_scores > self.threshold_).astype('int').ravel()
        np.place(confidence, prediction == 0, 1 - confidence[prediction == 0])

        return confidence

    def _fit(self, X, y=None, **kwargs):
        """Fit time series model to training data.

        """
        raise NotImplementedError(
            '_fit is a protected abstract method, it must be implemented.'
        )

    def _predict(self, X, **kwargs):
        """Predict labels for sequences in X.

        """
        raise NotImplementedError(
            '_predict is a protected abstract method, it must be implemented.'
        )

    def decision_function(self, X):
        """Predict anomaly scores for sequences in X.

        Parameters
        ----------
        X : numpy array of shape (n_samples, n_features).

        Returns
        -------
        anomaly_scores : numpy array of shape (n_samples,)
            The anomaly score of the input samples.
        """
        raise NotImplementedError('Not be implemented.')

    def _get_decision_attributes(self):
        """Calculate key attributes: threshold_ and labels_.

        Returns
        -------
        self : object.
        """

        self.threshold_ = np.percentile(self.decision_scores_, 100*(1-self.contamination))
        self.labels_ = (self.decision_scores_ > self.threshold_).astype('int').ravel()

        return self

    def _check_is_fitted(self):
        """Check if key attributes 'decision_scores_', 'threshold_',
           and 'labels_' are None.

        Returns
        -------
        True or False.
        """
        if self.decision_scores_ is None:
            return False
        elif self.threshold_ is None:
            return False
        elif self.labels_ is None:
            return False
        else:
            return True

    def _set_num_classes(self, y):
        """Set the number of classes if y is not None.

        Returns
        -------
        self : object.
        """
        if y is not None:
            check_classification_targets(y)
            self.classes_ = len(np.unique(y))
        return self
